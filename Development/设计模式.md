总结实际编码中使用过或常接触的设计模式



## 单例

Redis连接实例

IoC框架中以Singleton方式进行注入

## 观察者

摄像头可用状态检查

```c#

```



生产者/消费者

发布/订阅

## 发布订阅 ？

CAP模块

发布订阅与观察者间的区别：观察者和被观察对象间直接通讯，发布订阅通常有

## 简单工厂方法 & 抽象工厂

数据库连接

## 模板方法

之前写过一篇[模板方法模式实践](https://www.cnblogs.com/Cwj-XFH/p/7137102.html)，对模板方法做了一定介绍。模板方法在实际编码中还是挺常见的，如抽象类可以有不同的子类，其实就是模板方法的体现。

## 装饰器

装饰器就是不改变原有逻辑而对输出结果产生影响。对于装饰器使用比较有名的是Python中的装饰器，在语言层面进行了支持。在Python中，最简单的装饰器就是一个嵌套函数：

```python
import random

# 对计算结果加100
def add_num(func):
    def wrapper():
        r = func()
        r += 100
        return r
    return wrapper


@add_num
def random_num():
    return 22


print(random_num()) # 输出122
```



维护老旧代码是一件头发成本很高的事情，经常会遇到晦涩难懂的代码段，直接改动这些代码段风险较高，这时我们可以借助装饰器模式的思路来对原有代码逻辑进行扩展。如下，有一个复杂老旧的API`CalResult`，现需要对该API中的结果进行扩展，我们可以直接修改原有API中的逻辑，但成本较高且很难保证修改后的逻辑没有BUG。所以，我们可以不改变原逻辑而针对API的计算结果再做一次处理以规避风险：

```c#
public Result CalResult()
{
    // 复杂的逻辑处理
}

// 提供一个新的API对计算结果做再次处理
public Result CalResultDecorator()
{
    var tmpResult = CalResult();
    // 对tmpResult做相应处理
    return tmpResult;
}
```

若不需要考虑API向后兼容，则还可以使用下面方法：

```c#
// 继续使用原API，但将原有逻辑剥离出去
public Result CalResult()
{
    var tmpResult = CalResult();
    // 对tmpResult做相应处理
    return tmpResult;
}

// 将原有API的处理逻辑剥离出来
private Result CalResultCore()
{
    // 复杂的逻辑处理
}
```

>  :warning: 上述修改方法因为增加了一层调用，对性能可能会产生一定的负面影响

## 迭代器

语言层面

[C# 自定义可迭代类型](https://www.cnblogs.com/Cwj-XFH/p/12602783.html)

## 代理

nginx，JS中的Set对object去重

## 状态机



## 责任链



## 门面

redis操作的封装、EF Core中的DatabaseFacade

**Facade** is a structural design pattern that provides a simplified interface to a library, a framework, or any other complex set of classes.

## 建造者模式

OSS存储



.NET中Host的构建



## 小结

根据实际情况灵活使用