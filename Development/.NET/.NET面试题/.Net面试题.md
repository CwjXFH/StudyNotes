## 技术敏感度

当前用的.NET哪个版本？.NET最新版本是哪个？

C#语言发展到哪个版本了？C#最新版本特性有哪些？

接触过哪些开源项目？

## 基础

### 继承

问：.NET中子类可以继承父类中的哪些成员？

答：子类会继承父类中除构造函数和析构函数之外的所有成员，包括私有成员。不能在子类中访问父类的私有成员是因为访问修饰符的限制。可参考：[Inheritance - derive types to create more specialized behavior](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/inheritance)

![inheritance](imgs/inheritance.jpg)

#### 对象实例化机制

问：抽象类是否可以被实例化？是否可以有实例构造函数？不能实例化为什么要有实例构造函数？

答：抽象类不能被实例化，有示例构造函数。抽象类中可以包含实例成员，子类在初始化时会调用父类的实例构造函数初始化实例成员。

#### 重写

##### 语法规范

方法签名不能变更

[Beginning with C# 9.0, read-only overriding properties support covariant return types.](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/override)

针对protected internal的方法进行跨程序集override时，访问修饰符需变更为protected，参考示例重写EF Core中DbContext的OnModelCreating或OnConfiguring方法。参考文档：[Override methods](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/classes#override-methods)

##### new 和 override的区别

override只能用于virtual或者override成员

可使用sealed进制子类再override

new 可以是任意成员

参考：[Knowing When to Use Override and New Keywords (C# Programming Guide)](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/knowing-when-to-use-override-and-new-keywords)



## 进阶

### GC

有哪几种模式？workstation vs. server GC

Background vs Concurrent GC

参考：[Fundamentals of garbage collection](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals)

运行时如何配置，[Run-time configuration options for garbage collection](https://docs.microsoft.com/en-us/dotnet/core/run-time-config/garbage-collector)

### 异步

问：async void和async Task/async Task<T>的区别？

答：

问：什么是async/sync？什么是block/non-block？

答：根据任务发起者所在线程是否会被任务阻塞分为block和non-block，block模式，任务发起线程在获取到结果之前线程就等着，啥也不干。non-block则是任务发起线程会立即获得一个结果，这个结果不一定是任务计算后的实际值，实际任务的执行则有其他线程负责。 通常提到block和non-block时多指I/O操作。

​        根据任务发起者所在线程是否会等待任务结束分为async/sync。

### 多线程

问：.NET中线程有哪几种状态？状态间如何转换？

答：

阻塞、等待、挂起什么区别？这三种状态下的线程是否还能被用于执行其他任务？对线程池的影响？

block vs waiting

[漫话：如何给女朋友解释为什么Java线程没有Running状态？](https://mp.weixin.qq.com/s/Vr5E68TEcU2tu7-5K03MBA)

![](imgs/jvm线程状态.jpg)

问：I/O thread 和 Worker thread有什么区别

答：本质上没区别，只是用处不同。主要用于防范线程池中线程都用于等待I/O操作而导致系统无法响应。







### 线程安全

.NET provides a range of types that you can use to synchronize access to a shared resource or coordinate thread interaction: [Overview of synchronization primitives](https://docs.microsoft.com/en-us/dotnet/standard/threading/overview-of-synchronization-primitives)



#### 多线程操作文件

问：系统使用如NLog之类日志组件记录日志文件时，属于多线程场景。那么，NLog是如何避免多线程写冲突的？

答：



问：多线程读写文件如何做？

答：

```c#
// 运行这段代码，同时用记事本打开1.txt修改文件内容然后保存，控制台打印出新的文本内容
using var fs = new FileStream(@"C:\Users\eason\Desktop\1.txt", FileMode.Open, FileAccess.ReadWrite, FileShare.ReadWrite);
using var fr = new StreamReader(fs, Encoding.UTF8);
while (true)
{
    Console.WriteLine(fr.ReadToEnd());
    fs.Position = 0;
    Thread.Sleep(1 * 1000);
}
```



#### ThreadStatic vs ThreadLocal vs AsyncLocal





#### lock/Monitor vs SemaphoreSlim vs WaitHandle

![Semaphore & Lock & Mutex](imgs/Semaphore & Lock & Mutex.jpg)



问：lock语句中能不能使用await？若不能，为什么？

答：哪个线程使用lock加锁，就要有哪个线程负责释放。await/Task默认的调度机制是线程池，会有线程的切换，有可能导致锁无法释放。

```c#
class Program
{
    private static readonly object _obj = new object();

    static async Task Main(string[] args)
    {
        await LockAsync();
        Console.ReadKey();
    }
    
    static async Task LockAsync()
    {
        lock (_obj)
        {
            Console.WriteLine("lock");
            // Error CS1996: Cannot await in the body of a lock statement
            await Task.CompletedTask;
        }
    }
}
```





#### 锁

可重入锁、读写锁、公平锁、乐观锁、分布式锁(RedLock)





#### 并发集合

[System.Collections.Concurrent Namespace](https://docs.microsoft.com/en-us/dotnet/api/system.collections.concurrent?view=net-5.0)



### 性能与问题排查

#### 性能

性能问题分析通用套路
有哪些工具

#### 问题排查
dump文件


## 框架

### IoC

[Dependency injection in .NET](https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection)

.NET provides a built-in service container, [IServiceProvider](https://docs.microsoft.com/en-us/dotnet/api/system.iserviceprovider). Services are typically registered at the app's start-up, and appended to an [IServiceCollection](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.iservicecollection). Once all services are added, you use [BuildServiceProvider](https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.dependencyinjection.servicecollectioncontainerbuilderextensions.buildserviceprovider) to create the service container.



[Disposal of services](https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-guidelines#disposal-of-services)

> The container is responsible for cleanup of types it creates, and calls Dispose on [IDisposable](https://docs.microsoft.com/en-us/dotnet/api/system.idisposable) instances. Services resolved from the container should never be disposed by the developer. If a type or factory is registered as a singleton, the container disposes the singleton automatically.



[Scope validation](https://docs.microsoft.com/en-us/dotnet/core/extensions/dependency-injection#scope-validation)

Scoped services are disposed by the container that created them. If a scoped service is created in the root container, the service's lifetime is effectively promoted to singleton because it's only disposed by the root container when the app shuts down. Validating service scopes catches these situations when `BuildServiceProvider` is called.

### EF Core

#### DbContext

问：是否可以在async void方法中调用DbContext实例的异步方法？

答：不可用，DbContext不是线程安全的。async void方法无法被等待，有可能造成DbContext实例提前释放或者被多个线程使用的情况。

#### Model Configure



#### Migrations



#### CRUD



#### Change Tracking

[Change Tracking in EF Core](https://docs.microsoft.com/en-us/ef/core/change-tracking/)

Identity Resolution

问：Entity有几种状态？如何追踪Entity状态变化？

[Accessing Tracked Entities](https://docs.microsoft.com/en-us/ef/core/change-tracking/entity-entries)

#### 事务



#### 内部原理



### ASP.NET Core

#### 配置读取

问：ASP.NET Core中如何读取配置信息？

答：ASP.NET Core中配置信息的读取可使用IConfiguration接口，或者Options Pattern。Options Pattern提供了三个接口如下：

+ IOptions<TOptions>，生命周期是Singleton，应用启动后，无法感知配置信息的变化
+ IOptionsSnapshot<TOptions>，生命周期是Scope，每次使用时重新计算配置信息
+ IOptionsMonitor<TOptions>，生命周期是Singleton，可感知配置信息的变化

要告知配置信息的变化，在构建Host时要指定配置文件发生变化时重新加载配置文件：

```c#
public class Program
{
    public static void Main(string[] args)
    {
        new HostBuilder()
            .UseContentRoot(Directory.GetCurrentDirectory())
            .ConfigureAppConfiguration((hostBuilderContext, cfgBuilder) =>
            {
                // reloadOnChange参数设为true
                cfgBuilder.AddJsonFile("appsettings.json", false, true);
                cfgBuilder.AddJsonFile($"appsettings.{hostBuilderContext.HostingEnvironment.EnvironmentName}.json", false, true);
            })
            .ConfigureLogging(logBuilder =>
            {
                logBuilder.AddConsole();
                logBuilder.SetMinimumLevel(LogLevel.Information);
            })
            .ConfigureWebHostDefaults(hostBuilder =>
            {
                hostBuilder.UseStartup<Startup>();
            })
            .Build()
            .Run();
    }
}
```




>  IConfigureOptions<TOptions> vs IPostConfigureOptions<TOptions>


#### 环境变量



#### IoC

问：内置IoC容器有哪几种生命周期？

答：Singleton、Scope、Transient

问：不同生命周期的对象分别在什么时候被GC回收？

答：Scope对象在Http请求结束后可以被GC回收、Transient对象在使用完后即可被GC回收，Scope对象和Transient对象的回收时机不确定。Signleton对象在整个应用生命周期内不会被GC回收。



#### Middleware



#### 认证授权

Open Id/OAuth

JWT

ClaimIdentity



#### 打包发布



## 数据库



## Linux

参考《开发人员Linux面试》