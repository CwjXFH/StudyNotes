前段时间有同事问了一个问题：JavaScript是单线程运行代码，那么如下代码片段中，同样是执行`func1`和`func2`，为什么`Promise.all`相比于`await func1();await func2();`执行速度更快：

```javascript
async function func1() {
    await new Promise(resolve => {
        setTimeout(resolve, 3000);
    });
    return 100;
}

async function func2() {
    await new Promise(resolve => {
        setTimeout(resolve, 3000);
    });
    return 200;
}

(async function () {
    let result = [];
    // 约3秒返回结果
    result = await Promise.all([func1(), func2()]);
    // 约6秒返回结果
    // result[0] = await func1();
    // result[1] = await func2();
    console.log('result', result);
})();
```

当时并不能很好的回答这个问题，便查阅了相关资料整理如下：

## 并发模型

JavaScript使用基于事件循环的并发模型，这里并发指事件循环处理任务队列中回调函数的能力。该模型三大特点：**单线程、异步、非阻塞**。

单线程是指执行用户代码（或者说事件循环）的时候只有一个线程，即主线程。但JavaScript的Runtime不是单线程的。异步指主线程不用等待任务结果返回。非阻塞指任务执行过程不会导致事件循环停止，这里的非阻塞更多的是指I/O操作。JavaScript并发模型简化图示如下：

![](imgs/js_concurrenct_model.jpg)

与此类似Node执行用户代码也是用单线程，但Node内部不是单线程。下面是网上找的一张Node架构图，原图地址：[Node.js event loop architecture](https://medium.com/preezma/node-js-event-loop-architecture-go-deeper-node-core-c96b4cec7aa4)。可以看到Node中可能阻塞事件循环的任务，如：[未提供异步API的I/O操作及CPU密集型任务](https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#what-code-runs-on-the-worker-pool)会委托给`worker thread pool`来处理，不会影响到事件循环。

![](imgs/node_event_loop.png)



**Node event loop vs Browser event loop vs JavaScript event loop**

> Both the browser and NodeJS implements an asynchronous event-driven pattern with JavaScript. However, the “Events”, in a browser’s context, are user interactions on web pages (e.g, clicks, mouse movements, keyboard events etc.), but in Node’s context, events are asynchronous server-side operations (e.g, File I/O access, Network I/O etc.). Due to this difference of needs, Chrome and Node have different Event Loop implementations, though they share the same V8 JavaScript engine to run JavaScript.
>
> Since “the event loop” is nothing but a programming pattern, V8 allows the ability to plug-in an external event loop implementation to work with its JavaScript runtime. Using this flexibility, the Chrome browser uses [**libevent**](https://libevent.org/) as its event loop implementation, and NodeJS uses [**libuv**](https://libuv.org/) to implement the event loop. Therefore, chrome’s event loop and NodeJS’s event loop are based on two different libraries and which have differences, but they also share the similarities of the common “Event Loop” programming pattern.

## 协程

JavaScript异步编程大致经历了如下几个阶段：Callback、Promise、generator、async/await。

Callback大家都比较熟悉了，如：`SetTimeout`和`XMLHttpRequest`等API中使用回调来进行异步处理。

回调函数使用相对简单，但存在回调地狱问题，因此在ES6中引入了[Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)来解决该问题。但如果处理流程比较复杂的话，使用Promise代码中会用到大量的then分发，语义不清晰。

在ES7中引入了[await/async](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)，一个async函数会隐式返回一个Promise对象，await语句则会用到协程（Coroutine）。协程通常解释为**轻量级线程**，

最早接触协程的概念是在go中，后来发现好多语言都有，还是要多看多了解。

## 实现Pomise.all

实现一个简化版的`PromiseAll`：

```javascript
async function PromiseAll(values) {
    let result = [];
    for (let i = 0; i < values.length; i++) {
        await Promise.resolve(values[i]).then(value => {
            (async function () {
                let index = i;
                let tmpResult = await value;
                result[index] = tmpResult;
            })();
        });
    }

    if (result.length == values.length) {
        return result;
    }
}
```

使用`PromiseAll`来执行之前的异步函数：

```javascript
(async function () {
    console.log('before await');
    let result = [];
    result = await PromiseAll([func1(), func2()]);
    console.log('after await');
    console.log('result', result);
})();
console.log('end...');

// 输出如下：
// before await
// end...
// 间隔约3秒后输出
// after await
// result [ 100, 200 ]
```





##　对比Python中的异步



## 参考文章

[Node.js event loop architecture](https://medium.com/preezma/node-js-event-loop-architecture-go-deeper-node-core-c96b4cec7aa4)

[Javascript — single threaded, non-blocking, asynchronous, concurrent language](https://theflyingmantis.medium.com/javascript-single-threaded-non-blocking-asynchronous-concurrent-language-ffae97c57bef)

[Concurrency model and Event Loop](http://www-lia.deis.unibo.it/materiale/JS/developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop.html)

[JavaScript Event Loop vs Node JS Event Loop](https://blog.insiderattack.net/javascript-event-loop-vs-node-js-event-loop-aea2b1b85f5c)

[What code runs on the Worker Pool?](https://nodejs.org/en/docs/guides/dont-block-the-event-loop/#what-code-runs-on-the-worker-pool)

[Redis 多线程网络模型全面揭秘](https://segmentfault.com/a/1190000039223696)