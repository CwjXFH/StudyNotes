## 最简单的装饰器

Python中最简单的装饰器是一个嵌套函数。举例，使用装饰器函数`elapsed`来统计函数执行耗时：

```python
# _*_ coding=utf8 _*_

import time
import logging

logging.basicConfig(level=logging.INFO)


def elapsed(func):
    """统计函数执行耗时"""
    def wrapper():
        start_time = time.time()
        func()
        end_time = time.time()
        logging.info(f'exec {func.__name__} elapsed:{end_time-start_time}')
    return wrapper


def delay():
    logging.info('delay...')
    time.sleep(0.2)


# 装饰器就是普通函数，可以像普通函数那样直接调用
elapsed(delay)()

```

输出如下：

```shell
INFO:root:delay...
INFO:root:exec delay elapsed:0.20386290550231934
```

对于装饰器Python在语言层面给予了支持，对上面代码做如下修改：

```python
@elapsed
def delay():
    logging.info('delay...')
    time.sleep(0.2)


delay()

```

输出入下：

```shell
INFO:root:delay...
INFO:root:exec delay elapsed:0.21143507957458496
```



装饰器可以被多次使用：

```python
@elapsed
@elapsed
def delay():
    logging.info('delay...')
    time.sleep(0.2)


delay()

```

输出如下：

```shell
INFO:root:delay...
INFO:root:exec delay elapsed:0.21126818656921387
INFO:root:exec wrapper elapsed:0.21126818656921387
```

上述代码等价于如下调用方式：

```python
def delay():
    logging.info('delay...')
    time.sleep(0.2)


# 装饰器就是普通函数，可以像普通函数那样直接调用
# 这里多次调用装饰器函数
elapsed(elapsed(delay))()

```

调用堆栈如下：

```python
"""
logging.info() # wrapper, func=elapsed(delay)
logging.info() # wrapper, func=delay
logging.info() # delay中的log
delay()
wrapper() # func=delay
elapsed(delay)()
wrapper() # func=elapsed(delay)
elapsed(elapsed(delay))
"""
```



## 带参数的装饰器



## 类装饰器



## Python中的装饰器与装饰器模式

