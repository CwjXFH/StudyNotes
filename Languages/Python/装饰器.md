## 最简单的装饰器

Python中最简单的装饰器是一个嵌套函数。举例，使用装饰器函数`elapsed`来统计函数执行耗时：

```python
# _*_ coding=utf8 _*_

import time
import logging

logging.basicConfig(level=logging.INFO)


def elapsed(func):
    """统计函数执行耗时"""
    def wrapper():
        start_time = time.time()
        func()
        end_time = time.time()
        logging.info(f'exec {func.__name__} elapsed:{end_time-start_time}')
    return wrapper


def delay():
    logging.info('delay...')
    time.sleep(0.2)


# 装饰器就是普通函数，可以像普通函数那样直接调用
elapsed(delay)()

```

输出如下：

```shell
INFO:root:delay...
INFO:root:exec delay elapsed:0.20386290550231934
```

对于装饰器Python在语言层面给予了支持，对上面代码做如下修改：

```python
@elapsed
def delay():
    logging.info('delay...')
    time.sleep(0.2)


delay()

```

输出入下：

```shell
INFO:root:delay...
INFO:root:exec delay elapsed:0.21143507957458496
```

使用装饰器后，打印函数信息，无法输出原函数信息，执行`print(delay)`，输出`<function elapsed.<locals>.wrapper at 0x0000018E8AFA4E50>`。

这里可以使用`functools`模块来解决：

```python
import functools

def elapsed(func):
    """统计函数执行耗时"""
    @functools.wraps(func)
    def wrapper():
        start_time = time.time()
        func()
        end_time = time.time()
        logging.info(f'exec {func.__name__} elapsed:{end_time-start_time}')
    return wrapper

```

再次执行`print(delay)`，输出`<function delay at 0x00000186651B4E50>`。

装饰器可以被多次使用：

```python
@elapsed
@elapsed
def delay():
    logging.info('delay...')
    time.sleep(0.2)


delay()

```

输出如下：

```shell
INFO:root:delay...
INFO:root:exec delay elapsed:0.21126818656921387
INFO:root:exec wrapper elapsed:0.21126818656921387
```

上述代码等价于如下调用方式：

```python
def delay():
    logging.info('delay...')
    time.sleep(0.2)


# 装饰器就是普通函数，可以像普通函数那样直接调用
# 这里多次调用装饰器函数
elapsed(elapsed(delay))()

```

调用堆栈如下：

```python
"""
logging.info() # wrapper2
logging.info() # wrapper1
logging.info() # delay
delay()
wrapper1() # func=delay
wrapper2() # func=wrapper1
elapsed(wrapper1) # 返回新的wrapper，其中func指向wrapper1，这里记录为wrapper2
elapsed(delay) # 返回wrapper，其中func指向delay函数，这里记录为wrapper1
"""
```



## 带参数的装饰器

上节中提到的较为简单的装饰器是一个嵌套函数，带有参数的装饰器也是嵌套函数，只不过多嵌套一层：

```python
# _*_ coding=utf8 _*_

import logging
import functools

logging.basicConfig(level=logging.DEBUG)


def exec(count):
    def exec_wrapper(func):
        @functools.wraps(func)
        def func_wrapper():
            for i in range(count):
                logging.info(f'exec {func}')
                func()
        return func_wrapper
    return exec_wrapper


@exec(3)
def func():
    pass


func()

```

输出如下：

```shell
INFO:root:exec <function func at 0x000001A783724E50>
INFO:root:exec <function func at 0x000001A783724E50>
INFO:root:exec <function func at 0x000001A783724E50>
```



还可以给目标函数传递参数：



## 类装饰器



## Python中的装饰器与装饰器模式

